/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <camera_model/CameraModelParam.h>
#include <imu_types/ImuMeasurement.h>
#include <imu_types/ImuMeasurementModelParameters.h>
#include <imu_types/ImuNoiseModelParameters.h>
#include <point_observation/PointObservation.h>
#include <projectaria_tools/core/calibration/CameraCalibration.h>
#include <projectaria_tools/core/calibration/ImuMagnetometerCalibration.h>
#include <filesystem>

namespace visual_inertial_ba {

using namespace projectaria::tools::calibration;

using ImuMeasurement = ::imu_types::ImuMeasurement;
using ImuNoiseModelParameters = ::imu_types::ImuNoiseModelParameters;
using ImuMeasurementModelParameters = ::imu_types::ImuMeasurementModelParameters;

struct InertialPoseState {
  Sophus::SE3d T_w_IMU;
  Eigen::Vector3d v_w;
  Eigen::Vector3d omega_bodyImu;
  int64_t timestamp_us;
  int64_t utc_timestamp_ns;
  float qualityScore;
  std::string sessionOrGraphUid;
};

struct CalibrationState {
  // interface method
  CameraModelParam getConvertedCameraModelParam(int cameraIndex) const;

  // camera intrinsic, camera model parameters.
  std::vector<CameraCalibration> camParameters;

  // T_camera_imu extrinsics
  std::vector<Sophus::SE3d> T_Cam_BodyImu;

  // IMU state (biases and all the other stuff).
  std::vector<ImuMeasurementModelParameters> imuModelParameters;

  // T_camera_imu extrinsics, ONLY for secondary IMUs
  std::vector<Sophus::SE3d> T_Imu_BodyImu;

  int64_t timestamp_us = 0;
};

struct SessionData {
  void
  load(const std::filesystem::path& sessDataPath, bool loadImuMeasurements, bool verbose = true);

  struct {
    std::vector<std::string> cameraSerialNumbers;
    std::vector<std::string> cameraLabels;
    std::vector<std::string> imuLabels;

    CalibrationState calib;

    // imu noise models
    std::vector<ImuNoiseModelParameters> imuNoiseModels;
  } factoryCalibration;

  // info about how SLAM ran (camera indices MATCH those in tracking points)
  struct {
    std::vector<std::string> cameraSerialNumbers;
    std::vector<std::string> imuLabels;

    Sophus::SE3d T_bodyImu_device; // body Imu is first one AS DURING SLAM
  } slamInfo;

  // all measurements for all Imus, ordered according to SLAM's device index
  std::vector<std::vector<ImuMeasurement>> allImuMeasurements;

  // per frame init estimates (pose, vel, omega)
  std::vector<InertialPoseState> inertialPoses;

  // full per-frame calibration (NOTE: device index is remapped)
  struct {
    std::vector<std::string> cameraSerialNumbers;
    std::vector<std::string> cameraLabels;
    std::vector<std::string> imuLabels;
    std::vector<CalibrationState> calibs;
  } onlineCalibration;

  // tracking points (use SLAM's device index)
  std::vector<PointObservation> trackingObservations;

  // "reset_events.json" as generated by T3, or empty
  std::vector<int64_t> resetTimeStampsUs;
};

} // namespace visual_inertial_ba
